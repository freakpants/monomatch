<!DOCTYPE html>
<html>

<head>
    <script src="phaser/dist/phaser.js"></script>
    <script type="text/javascript" src="https://www.airconsole.com/api/airconsole-1.7.0.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Oswald|Roboto" rel="stylesheet">

    <script src="js/fontLoader.js"></script>
    <script src="https://kit.fontawesome.com/e986f25b5a.js" crossorigin="anonymous"></script>

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            position: absolute;
        }
    </style>
</head>

<body onload="init()">
    <audio id="music-element" autoplay loop>
        <source src="audio/flaing-piano-loop-8782.mp3" type="audio/mpeg">
    </audio>
    <script>

        // store current scores of players
        document.playerScores = [];
        document.connectedPlayersAmount = 0;
        document.maxRound = 20;
        document.gameScene = "mainmenu";
        document.rotationOff = true;
        document.scalingOff = true;
        document.correct_icon_id = -1;

        var DEBUG = true;
        function sceneChange(targetScene) {
            document.gameScene = targetScene;
            DEBUG && console.log("scenechange to " + targetScene + " was triggered.");
            document.game.scene.getScene('backgroundanduiscene').events.emit("sceneChange", targetScene);
            var command = [];
            command.push({ type: "sceneChange", scene: targetScene });
            air_console.broadcast(command);
        }

        function update_maxRound_on_controllers() {
            var command = [];
            command.push({ type: "maxRound", maxRound: document.maxRound });
            air_console.broadcast(command);
        }

        function generate_stack() {
            // build the stack of cards
            document.stack = [];
            while (document.stack.length < 3) {
                var r = Math.floor(Math.random() * 57);
                if (document.stack.indexOf(r) === -1) document.stack.push(r);
            }
            DEBUG && console.log("building stack");
            DEBUG && console.log(document.stack);
        }


        function init() {
            air_console = new AirConsole();

            // Listen for messages from other devices
            air_console.onMessage = function (from, message) {
                // handle message
                var type = message[0].type;
                DEBUG && console.log('handling ' + type + ' message on screen.');

                switch (type) {
                    case "request_icons":
                        if (document.stack.length === 0) {
                            generate_stack();
                        }
                        set_message = [];
                        set_message.push({ type: "set", update: false, set_id: document.stack[0], screen_set_id: document.set_id });
                        DEBUG && console.log("sending set info to device " + from);
                        air_console.message(from, set_message);
                        document.stack.shift();
                        break;
                    case "more":
                        document.maxRound += 5;
                        update_maxRound_on_controllers();
                        break;
                    case "less":
                        document.maxRound -= 5;
                        update_maxRound_on_controllers();
                        break;
                    case "next":
                        // change to next scene depending on current scene in a switch
                        switch (document.gameScene) {
                            case "musicoptionsscene":
                                sceneChange("roundoptionsscene");
                                break;
                            case "roundoptionsscene":
                                sceneChange("difficultyoptionsscene");
                                break;
                        }
                        break;
                    case "back":
                        switch (document.gameScene) {
                            case "musicoptionsscene":
                                sceneChange("mainmenu");
                                break;
                            case "roundoptionsscene":
                                sceneChange("musicoptionsscene");
                                break;
                            case "difficultyoptionsscene":
                                sceneChange("roundoptionsscene");
                                break;
                        }
                        break;
                    case "toggle-rotation":
                        document.rotationOff = !document.rotationOff;
                        break;
                    case "toggle-scaling":
                        document.scalingOff = !document.scalingOff;
                        break;
                    case "toggle-sfx":
                        if (document.sfxOff) {
                            document.sfxOff = false;
                        } else {
                            document.sfxOff = true;
                        }
                        DEBUG && console.log("emmitting optionChange event");
                        document.game.scene.getScene('backgroundanduiscene').events.emit("optionChange", "sfx");
                        sceneChange("musicoptionsscene");
                        break;
                    case "toggle-music":

                        if (document.musicOff) {
                            $("#music-element").prop("volume", 1);
                            document.musicOff = false;
                        } else {
                            $("#music-element").prop("volume", 0);
                            document.musicOff = true;
                        }
                        DEBUG && console.log("emmitting optionChange event");
                        document.game.scene.getScene('backgroundanduiscene').events.emit("optionChange", "music");
                        sceneChange("musicoptionsscene");
                        break;
                    case "options":
                        sceneChange("musicoptionsscene");
                        break;
                    case "resume":
                        sceneChange("guessing");
                        var command = [];
                        command.push({ type: "resume" });
                        air_console.broadcast(command);
                        break;
                    case "pause":
                        // pause game
                        sceneChange("pausescreen");
                        break;
                    case "back_to_main":
                        sceneChange("mainmenu");
                        break;
                    case "correct":
                        if (document.somebodyScoredThisRound) {
                            return;
                        }
                        document.somebodyScoredThisRound = true;

                        DEBUG && console.log("device " + from + " guessed correctly");
                        DEBUG && console.log("correct set was: " + message[0].set_id);

                        // try selecting current score
                        playerScore = document.playerScores.filter(function (obj) {
                            return obj.player === from;
                        });

                        // increase the score 

                        if (playerScore[0]) {
                            playerScore[0].correct++;
                        } else {
                            document.playerScores.push({ player: from, correct: 1 });
                        }


                        // conventionally sort the scores
                        document.playerScores.sort(function (a, b) {
                            if (a.correct > b.correct) {
                                return -1;
                            }
                            if (a.correct < b.correct) {
                                return 1;
                            }
                            return 0;
                        });

                        // assign a position giving the same position to players with the same score
                        let position = 0;
                        let previous_correct = false;
                        document.playerScores.forEach(function (score, index) {
                            if (previous_correct !== score.correct) {
                                // only increase position if the score is different than the previous one
                                position++;
                            }
                            score.position = position;
                            previous_correct = score.correct;

                            // send the position and score to the respective client
                            score_message = [];
                            score_message.push({ type: "score", correct: score.correct, position: score.position });
                            DEBUG && console.log("sending score info to device " + score.player);
                            air_console.message(score.player, score_message);
                        });

                        DEBUG && console.log("playerscores:");
                        DEBUG && console.log(document.playerScores);

                        document.winningPlayerId = from;


                        if (document.lastRound) {
                            // if this was the last round, move on to the game over screen
                            DEBUG && console.log("game is ending");
                            game_over_message = [];
                            game_over_message.push({ type: "game_over" });
                            DEBUG && console.log("sending game over message");
                            air_console.broadcast(game_over_message);
                            sceneChange('endofgame');
                        } else {
                            // change the phaser scene
                            // sceneChange("timescreen");
                            document.correct_icon_id = message[0].correct_icon_id;

                            document.next_set_id = message[0].set_id;
                            document.round++;

                            // check if the game is ending
                            if (document.round === document.maxRound) {
                                DEBUG && console.log("game is ending this round!");
                                document.lastRound = true;
                            }

                            // if stack is empty, regenerate it
                            if (document.stack.length === 0) {
                                generate_stack();
                            }

                            // send new set to device
                            DEBUG && console.log("sending new sets to winner");
                            set_message = [];
                            set_message.push({ type: "set", update: true, set_id: document.stack[0], screen_set_id: document.next_set_id });
                            DEBUG && console.log("sending set info to device " + from);
                            air_console.message(from, set_message);
                            document.stack.shift();

                            message = [];
                            message.push({ type: "new_screen_set", screen_set_id: document.next_set_id });
                            air_console.broadcast(message);

                            // also inform all clients that are not the reporting client that they were to slow 
                            air_console.getControllerDeviceIds().forEach(function (id) {
                                if (id !== from) {
                                    message = [];
                                    message.push({ type: "correct", player: from });
                                    air_console.message(id, message);
                                }
                            });
                        }
                        break;
                    case "confirm":
                        if (!(document.connectedPlayersAmount >= 2 && document.connectedPlayersAmount <= 8)) {
                            return;
                        }
                        document.round = 1;

                        // document.maxRound = 57 - document.connectedPlayersAmount;

                        document.somebodyScoredThisRound = false;

                        generate_stack();



                        // get the first card from the stack
                        document.set_id = document.stack[0];
                        document.stack.shift();

                        document.set = document.projective_sets.filter(obj => {
                            return obj.id === document.set_id
                        });

                        DEBUG && console.log(document.stack);

                        document.lastRound = false;
                        // reset scores of players
                        document.playerScores = [];

                        // also reset the score on all controllers
                        score_message = [];
                        score_message.push({ type: "score", correct: 0, position: 1 });
                        DEBUG && console.log("resetting all controllers to 0 points");
                        air_console.broadcast(score_message);

                        // initialize score for every player so we can determine position after first round
                        air_console.getControllerDeviceIds().forEach(function (id) {
                            document.playerScores.push({ player: id, correct: 0 });
                        });

                        // assign a card from the stack to every client
                        var deviceIds = air_console.getControllerDeviceIds();
                        deviceIds.forEach(device_id => {
                            set_message = [];
                            set_message.push({ type: "set", set_id: document.stack[0], screen_set_id: document.set_id });
                            DEBUG && console.log("sending set info to device " + device_id);
                            air_console.message(device_id, set_message);
                            document.stack.shift();
                        });

                        // change the phaser scene
                        sceneChange("guessing");

                        break;
                }
            };
            air_console.onConnect = function (device_id) {

                // let the new controller know which screen we are on
                var command = [];
                command.push({ type: "sceneChange", scene: document.gameScene });
                air_console.message(device_id, command);

                update_maxRound_on_controllers();

                // update player count
                document.connectedPlayersAmount = air_console.getControllerDeviceIds().length;

                /* prepare messages for clients */
                show_menu = [];
                show_menu.push({
                    type: "show_menu"
                });
                hide_menu = [];
                hide_menu.push({
                    type: "hide_menu"
                });

                // if there is no round in progress, check if the connected device is the master
                if (air_console.getMasterControllerDeviceId() !== undefined && air_console.getMasterControllerDeviceId() === device_id) {
                    DEBUG && console.log("device " + device_id + " is the master");
                    // let the new client know to display the menu)
                    air_console.message(device_id, show_menu);
                    // also let all other clients know NOT to display the menu anymore
                    air_console.getControllerDeviceIds().forEach(function (id) {
                        if (id === device_id) return;
                        air_console.message(id, hide_menu);
                    });
                } else {
                    DEBUG && console.log("device " + device_id + " is not a master");
                    air_console.message(device_id, hide_menu);
                }
                // trigger the event on the active scene
                if (typeof document.game !== "undefined" && document.game.scene.getScenes(true).length > 0) {
                    document.game.scene.getScene('backgroundanduiscene').events.emit("playerConnectionEvent");
                }
            }


            air_console.onDisconnect = function (device_id) {
                // update player count
                document.connectedPlayersAmount = air_console.getControllerDeviceIds().length;


                // let the new master know to display the menu
                if (air_console.getMasterControllerDeviceId() !== undefined) {
                    message = [];
                    message.push({
                        type: "show_menu"
                    });
                    air_console.message(air_console.getMasterControllerDeviceId(), message);
                }
                // trigger the event on the active scene
                if (document.game.scene.getScenes(true).length > 0) {
                    document.game.scene.getScene('backgroundanduiscene').events.emit("playerConnectionEvent");
                }
            }

        }

    </script>
    <script type="module">
        import Guessing from './scenes/Guessing.js';
        import MainMenu from './scenes/MainMenu.js';
        import TimeScreen from './scenes/TimeScreen.js';
        import EndOfGame from './scenes/EndOfGame.js';
        import PauseScreen from './scenes/PauseScreen.js';
        import BootScene from './scenes/BootScene.js';
        import BackgroundAndUIScene from './scenes/BackgroundAndUIScene.js';
        import MusicOptions from './scenes/MusicOptions.js';
        import RoundOptions from './scenes/RoundOptions.js';
        import DifficultyOptions from './scenes/DifficultyOptions.js';
        import { objects, projective_sets } from './objects.js';

        $(document).ready(function () {

            document.projective_sets = projective_sets;

            var config = {
                type: Phaser.AUTO,
                scale: {
                    mode: Phaser.Scale.NONE,
                    parent: 'body',
                    width: "100%",
                    height: "100%",
                    autoCenter: Phaser.Scale.NO_CENTER,
                },
                scene: [BootScene, BackgroundAndUIScene, MainMenu, Guessing, TimeScreen, EndOfGame, PauseScreen, MusicOptions, RoundOptions, DifficultyOptions],
                transparent: true
            };

            document.game = new Phaser.Game(config);

            document.uiScale = Math.sqrt((document.game.scale.parentSize._width * document.game.scale.parentSize._height) / (1920 * 1016));

        });

    </script>

</body>

</html>